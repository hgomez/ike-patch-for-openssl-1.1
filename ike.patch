diff -Nru -X exclude-ext ike.orig/source/iked/crypto.cpp ike/source/iked/crypto.cpp
--- ike.orig/source/iked/crypto.cpp	2012-12-11 07:56:33.000000000 +0100
+++ ike/source/iked/crypto.cpp	2019-01-10 17:44:02.631489567 +0100
@@ -376,60 +376,51 @@
 	if( dh == NULL )
 		return false;
 
-	dh->p = NULL;
-	dh->g = NULL;
-	dh->length = 0;
-
-	//
-	// set p ( prime ) value
-	//
-
 	unsigned char * p_data = NULL;
 	size_t			p_size = 0;
 
-	dh->p = BN_new();
-	if( dh->p == NULL )
-		goto dh_failed;
+    BIGNUM *member_p = BN_new();
+    BIGNUM *member_g = BN_new();
 
 	switch( group )
 	{
 		case 1:
-			if( !BN_bin2bn( group1, sizeof( group1 ), dh->p ) )
+			if( !BN_bin2bn( group1, sizeof( group1 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 2:
-			if( !BN_bin2bn( group2, sizeof( group2 ), dh->p ) )
+			if( !BN_bin2bn( group2, sizeof( group2 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 5:
-			if( !BN_bin2bn( group5, sizeof( group5 ), dh->p ) )
+			if( !BN_bin2bn( group5, sizeof( group5 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 14:
-			if( !BN_bin2bn( group14, sizeof( group14 ), dh->p ) )
+			if( !BN_bin2bn( group14, sizeof( group14 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 15:
-			if( !BN_bin2bn( group15, sizeof( group15 ), dh->p ) )
+			if( !BN_bin2bn( group15, sizeof( group15 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 16:
-			if( !BN_bin2bn( group16, sizeof( group16 ), dh->p ) )
+			if( !BN_bin2bn( group16, sizeof( group16 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 17:
-			if( !BN_bin2bn( group17, sizeof( group17 ), dh->p ) )
+			if( !BN_bin2bn( group17, sizeof( group17 ), member_p ) )
 				goto dh_failed;
 			break;
 
 		case 18:
-			if( !BN_bin2bn( group18, sizeof( group18 ), dh->p ) )
+			if( !BN_bin2bn( group18, sizeof( group18 ), member_p ) )
 				goto dh_failed;
 			break;
 
@@ -437,17 +428,14 @@
 			goto dh_failed;
 	}
 
-	//
-	// set g ( generator ) value
-	//
 
-	dh->g = BN_new();
-	if( dh->g == NULL )
-		goto dh_failed;
+    DH_set0_pqg(dh, member_p, NULL, NULL);
 
-	if( !BN_set_word( dh->g, 2 ) )
+	if( !BN_set_word( member_g, 2 ) )
 		goto dh_failed;
 
+    DH_set0_pqg(dh, member_p, NULL, member_g);
+
 	//
 	// generate private and public DH values
 	//
@@ -456,13 +444,19 @@
 		goto dh_failed;
 
 	*dh_data = dh;
-	*dh_size = BN_num_bytes( dh->p );
+	*dh_size = (long)BN_num_bytes( member_p );
+
+	DH_free( dh );
+	BN_clear_free(member_p);
+	BN_clear_free(member_g);
 
 	return true;
 
 	dh_failed:
 
 	DH_free( dh );
+	BN_clear_free(member_p);
+	BN_clear_free(member_g);
 
 	return false;
 }
diff -Nru -X exclude-ext ike.orig/source/iked/ike.cpp ike/source/iked/ike.cpp
--- ike.orig/source/iked/ike.cpp	2009-02-12 03:35:43.000000000 +0100
+++ ike/source/iked/ike.cpp	2019-01-10 17:56:05.421173424 +0100
@@ -391,11 +391,11 @@
 	// init cipher key and iv
 	//
 
-	EVP_CIPHER_CTX ctx_cipher;
-	EVP_CIPHER_CTX_init( &ctx_cipher );
+	EVP_CIPHER_CTX * ctx_cipher;
+	ctx_cipher = EVP_CIPHER_CTX_new();
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		sa->evp_cipher,
 		NULL,
 		NULL,
@@ -403,11 +403,11 @@
 		0 );
 
 	EVP_CIPHER_CTX_set_key_length(
-		&ctx_cipher,
+		ctx_cipher,
 		( int ) sa->key.size() );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		NULL,
 		NULL,
 		sa->key.buff(),
@@ -415,16 +415,16 @@
 		0 );
 
 	//
-	// decrypt all but header
 	//
+	// decrypt all but header
 
 	EVP_Cipher(
-		&ctx_cipher,
+		ctx_cipher,
 		data + sizeof( IKE_HEADER ),
 		data + sizeof( IKE_HEADER ),
 		( int ) size - sizeof( IKE_HEADER ) );
 
-	EVP_CIPHER_CTX_cleanup( &ctx_cipher );
+	EVP_CIPHER_CTX_free( ctx_cipher );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -595,11 +595,12 @@
 	// encrypt all but header
 	//
 
-	EVP_CIPHER_CTX ctx_cipher;
-	EVP_CIPHER_CTX_init( &ctx_cipher );
+	EVP_CIPHER_CTX * ctx_cipher;
+	ctx_cipher = EVP_CIPHER_CTX_new();
+	EVP_CIPHER_CTX_init( ctx_cipher );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		sa->evp_cipher,
 		NULL,
 		NULL,
@@ -607,11 +608,11 @@
 		1 );
 
 	EVP_CIPHER_CTX_set_key_length(
-		&ctx_cipher,
+		ctx_cipher,
 		( int ) sa->key.size() );
 
 	EVP_CipherInit_ex(
-		&ctx_cipher,
+		ctx_cipher,
 		NULL,
 		NULL,
 		sa->key.buff(),
@@ -619,12 +620,12 @@
 		1 );
 
 	EVP_Cipher(
-		&ctx_cipher,
+		ctx_cipher,
 		data + sizeof( IKE_HEADER ),
 		data + sizeof( IKE_HEADER ),
 		( int ) size - sizeof( IKE_HEADER ) );
 
-	EVP_CIPHER_CTX_cleanup( &ctx_cipher );
+	EVP_CIPHER_CTX_free( ctx_cipher );
 
 	//
 	// store cipher iv data
diff -Nru -X exclude-ext ike.orig/source/iked/ike.exch.config.cpp ike/source/iked/ike.exch.config.cpp
--- ike.orig/source/iked/ike.exch.config.cpp	2013-04-07 18:28:06.000000000 +0200
+++ ike/source/iked/ike.exch.config.cpp	2019-01-10 17:51:47.959155627 +0100
@@ -2481,15 +2481,15 @@
 	BDATA hash_c;
 	hash_c.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &msgid, 4 );
-	HMAC_Update( &ctx_prf, cfg->hda.buff(), cfg->hda.size() );
-	HMAC_Final( &ctx_prf, hash_c.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &msgid, 4 );
+	HMAC_Update( ctx_prf, cfg->hda.buff(), cfg->hda.size() );
+	HMAC_Final( ctx_prf, hash_c.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -2543,15 +2543,15 @@
 	// create message authentication hash
 	//
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &cfg->msgid, sizeof( cfg->msgid ) );
-	HMAC_Update( &ctx_prf, packet.buff() + beg, end - beg );
-	HMAC_Final( &ctx_prf, hash.buff(), 0 );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &cfg->msgid, sizeof( cfg->msgid ) );
+	HMAC_Update( ctx_prf, packet.buff() + beg, end - beg );
+	HMAC_Final( ctx_prf, hash.buff(), 0 );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	memcpy( packet.buff() + off + 4, hash.buff(), hash.size() );
 
diff -Nru -X exclude-ext ike.orig/source/iked/ike.exch.inform.cpp ike/source/iked/ike.exch.inform.cpp
--- ike.orig/source/iked/ike.exch.inform.cpp	2010-12-02 17:06:10.000000000 +0100
+++ ike/source/iked/ike.exch.inform.cpp	2019-01-10 17:59:10.226512560 +0100
@@ -399,15 +399,15 @@
 	BDATA hash_c;
 	hash_c.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &inform->msgid, 4 );
-	HMAC_Update( &ctx_prf, inform->hda.buff(), inform->hda.size() );
-	HMAC_Final( &ctx_prf, hash_c.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &inform->msgid, 4 );
+	HMAC_Update( ctx_prf, inform->hda.buff(), inform->hda.size() );
+	HMAC_Final( ctx_prf, hash_c.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -439,15 +439,15 @@
 {
 	inform->hash_l.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &inform->msgid, sizeof( inform->msgid ) );
-	HMAC_Update( &ctx_prf, inform->hda.buff(), inform->hda.size() );
-	HMAC_Final( &ctx_prf, inform->hash_l.buff(), 0 );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &inform->msgid, sizeof( inform->msgid ) );
+	HMAC_Update( ctx_prf, inform->hda.buff(), inform->hda.size() );
+	HMAC_Final( ctx_prf, inform->hash_l.buff(), 0 );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
diff -Nru -X exclude-ext ike.orig/source/iked/ike.exch.phase1.cpp ike/source/iked/ike.exch.phase1.cpp
--- ike.orig/source/iked/ike.exch.phase1.cpp	2012-02-08 06:09:35.000000000 +0100
+++ ike/source/iked/ike.exch.phase1.cpp	2019-01-10 18:10:30.956331182 +0100
@@ -1044,14 +1044,13 @@
 								BDATA psk_hash;
 								psk_hash.size( ph1->hash_size );
 
-								HMAC_CTX ctx_prf;
-								HMAC_CTX_init( &ctx_prf );
+								HMAC_CTX * ctx_prf;
 
-								HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-								HMAC_Update( &ctx_prf, ph1->tunnel->peer->psk.buff(), ph1->tunnel->peer->psk.size() );
-								HMAC_Final( &ctx_prf, psk_hash.buff(), NULL );
+								HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+								HMAC_Update( ctx_prf, ph1->tunnel->peer->psk.buff(), ph1->tunnel->peer->psk.size() );
+								HMAC_Final( ctx_prf, psk_hash.buff(), NULL );
 
-								HMAC_CTX_cleanup( &ctx_prf );
+								HMAC_CTX_free( ctx_prf );
 
 								//
 								// add the notification payload
@@ -1557,7 +1556,10 @@
 	{
 		BDATA prv;
 		prv.size( ph1->dh_size );
-		BN_bn2bin( ph1->dh->priv_key, prv.buff() );
+        const BIGNUM *private_key;
+
+		DH_get0_key(ph1->dh, NULL, &private_key);
+		BN_bn2bin( private_key, prv.buff() );
 
 		log.bin(
 			LLOG_DECODE,
@@ -1656,25 +1658,24 @@
 		case XAUTH_AUTH_INIT_PSK:
 		case XAUTH_AUTH_RESP_PSK:
 		{
-			HMAC_CTX ctx_prf;
-			HMAC_CTX_init( &ctx_prf );
+			HMAC_CTX * ctx_prf;
 
-			HMAC_Init_ex( &ctx_prf, ph1->tunnel->peer->psk.buff(), ( int ) ph1->tunnel->peer->psk.size(), ph1->evp_hash, NULL );
+			HMAC_Init_ex( ctx_prf, ph1->tunnel->peer->psk.buff(), ( int ) ph1->tunnel->peer->psk.size(), ph1->evp_hash, NULL );
 
 			if( ph1->initiator )
 			{
-				HMAC_Update( &ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
-				HMAC_Update( &ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
 			}
 			else
 			{
-				HMAC_Update( &ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
-				HMAC_Update( &ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_r.buff(), ph1->nonce_r.size() );
+				HMAC_Update( ctx_prf, ph1->nonce_l.buff(), ph1->nonce_l.size() );
 			}
 
-			HMAC_Final( &ctx_prf, skeyid_data, NULL );
+			HMAC_Final( ctx_prf, skeyid_data, NULL );
 
-			HMAC_CTX_cleanup( &ctx_prf );
+			HMAC_CTX_free( ctx_prf );
 
 			break;
 		}
@@ -1704,14 +1705,13 @@
 				nonce.add( ph1->nonce_l );
 			}
 
-			HMAC_CTX ctx_prf;
-			HMAC_CTX_init( &ctx_prf );
+			HMAC_CTX * ctx_prf;
 
-			HMAC_Init_ex( &ctx_prf, nonce.buff(), ( int ) nonce.size(), ph1->evp_hash, NULL );
-			HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-			HMAC_Final( &ctx_prf, skeyid_data, NULL );
+			HMAC_Init_ex( ctx_prf, nonce.buff(), ( int ) nonce.size(), ph1->evp_hash, NULL );
+			HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+			HMAC_Final( ctx_prf, skeyid_data, NULL );
 
-			HMAC_CTX_cleanup( &ctx_prf );
+			HMAC_CTX_free( ctx_prf );
 
 			break;
 		}	
@@ -1730,15 +1730,14 @@
 	// compute SKEYID_d
 	//
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\0", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ( unsigned char * ) "\0", 1 );
+	HMAC_Final( ctx_prf, skeyid_data, NULL );
 
 	ph1->skeyid_d.set( skeyid_data, skeyid_size );
 
@@ -1753,13 +1752,13 @@
 	// compute SKEYID_a
 	//
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, skeyid_data, skeyid_size );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\1", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, skeyid_data, skeyid_size );
+	HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ( unsigned char * ) "\1", 1 );
+	HMAC_Final( ctx_prf, skeyid_data, NULL );
 
 	ph1->skeyid_a.set( skeyid_data, skeyid_size );
 
@@ -1774,13 +1773,13 @@
 	// compute SKEYID_e
 	//
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, skeyid_data, skeyid_size );
-	HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
-	HMAC_Update( &ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) "\2", 1 );
-	HMAC_Final( &ctx_prf, skeyid_data, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid.buff(), ( int ) ph1->skeyid.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, skeyid_data, skeyid_size );
+	HMAC_Update( ctx_prf, shared.buff(), shared.size() );
+	HMAC_Update( ctx_prf, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, ( unsigned char * ) "\2", 1 );
+	HMAC_Final( ctx_prf, skeyid_data, NULL );
 
 	ph1->skeyid_e.set( skeyid_data, skeyid_size );
 
@@ -1821,15 +1820,15 @@
 
 		// create extended key data
 
-		HMAC_Init_ex( &ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
-		HMAC_Update( &ctx_prf, ( unsigned char * ) "\0", 1 );
-		HMAC_Final( &ctx_prf, key_data, NULL );
+		HMAC_Init_ex( ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
+		HMAC_Update( ctx_prf, ( unsigned char * ) "\0", 1 );
+		HMAC_Final( ctx_prf, key_data, NULL );
 
 		for( long size = skeyid_size; size < key_size; size += skeyid_size )
 		{
-			HMAC_Init_ex( &ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
-			HMAC_Update( &ctx_prf, key_data + size - skeyid_size, skeyid_size );
-			HMAC_Final( &ctx_prf, key_data + size, NULL );
+			HMAC_Init_ex( ctx_prf, skeyid_data, skeyid_size, ph1->evp_hash, NULL );
+			HMAC_Update( ctx_prf, key_data + size - skeyid_size, skeyid_size );
+			HMAC_Final( ctx_prf, key_data + size, NULL );
 		}
 	}
 	else
@@ -1839,7 +1838,7 @@
 		memcpy( key_data, skeyid_data, key_size );
 	}
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	if( proposal->ciph_kl )
 		key_size = ( proposal->ciph_kl + 7 ) / 8;
@@ -1860,22 +1859,23 @@
 	unsigned char iv_data[ HMAC_MAX_MD_CBLOCK ];
 	unsigned long iv_size = EVP_CIPHER_iv_length( ph1->evp_cipher );
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
+	EVP_MD_CTX * ctx_hash;
+	ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
 
 	if( ph1->initiator )
 	{
-		EVP_DigestUpdate( &ctx_hash, ph1->xl.buff(), ph1->xl.size() );
-		EVP_DigestUpdate( &ctx_hash, ph1->xr.buff(), ph1->xr.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xl.buff(), ph1->xl.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xr.buff(), ph1->xr.size() );
 	}
 	else
 	{
-		EVP_DigestUpdate( &ctx_hash, ph1->xr.buff(), ph1->xr.size() );
-		EVP_DigestUpdate( &ctx_hash, ph1->xl.buff(), ph1->xl.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xr.buff(), ph1->xr.size() );
+		EVP_DigestUpdate( ctx_hash, ph1->xl.buff(), ph1->xl.size() );
 	}
 
-	EVP_DigestFinal( &ctx_hash, iv_data, NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_DigestFinal( ctx_hash, iv_data, NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	ph1->iv.set( iv_data, iv_size );
 
@@ -1903,29 +1903,29 @@
 
 	hash.size( sa->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
 
 	if( sa->initiator )
 	{
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
 	}
 
-	HMAC_Update( &ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->hda.buff(), sa->hda.size() );
-	HMAC_Update( &ctx_prf, sa->idi.buff(), sa->idi.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Update( ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->hda.buff(), sa->hda.size() );
+	HMAC_Update( ctx_prf, sa->idi.buff(), sa->idi.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1945,29 +1945,29 @@
 
 	hash.size( sa->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf, sa->skeyid.buff(), ( int ) sa->skeyid.size(), sa->evp_hash, NULL );
 
 	if( sa->initiator )
 	{
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, sa->xl.buff(), sa->xl.size() );
-		HMAC_Update( &ctx_prf, sa->xr.buff(), sa->xr.size() );
+		HMAC_Update( ctx_prf, sa->xl.buff(), sa->xl.size() );
+		HMAC_Update( ctx_prf, sa->xr.buff(), sa->xr.size() );
 	}
 
-	HMAC_Update( &ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
-	HMAC_Update( &ctx_prf, sa->hda.buff(), sa->hda.size() );
-	HMAC_Update( &ctx_prf, sa->idr.buff(), sa->idr.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Update( ctx_prf, sa->cookies.r, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->cookies.i, ISAKMP_COOKIE_SIZE );
+	HMAC_Update( ctx_prf, sa->hda.buff(), sa->hda.size() );
+	HMAC_Update( ctx_prf, sa->idr.buff(), sa->idr.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -2569,14 +2569,15 @@
 	// hash for remote address
 	//
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_addr.s_addr, 4 );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_port, 2 );
-	EVP_DigestFinal( &ctx_hash, natd.buff(), NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_MD_CTX * ctx_hash;
+	ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_addr.s_addr, 4 );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_r.saddr4.sin_port, 2 );
+	EVP_DigestFinal( ctx_hash, natd.buff(), NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	ph1->natd_hash_l.add( natd );
 
@@ -2585,13 +2586,14 @@
 	// hash for local address
 	//
 
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_addr.s_addr, 4 );
-	EVP_DigestUpdate( &ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_port, 2 );
-	EVP_DigestFinal( &ctx_hash, natd.buff(), NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.i, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, ph1->cookies.r, ISAKMP_COOKIE_SIZE );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_addr.s_addr, 4 );
+	EVP_DigestUpdate( ctx_hash, &ph1->tunnel->saddr_l.saddr4.sin_port, 2 );
+	EVP_DigestFinal( ctx_hash, natd.buff(), NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	ph1->natd_hash_l.add( natd );
 
diff -Nru -X exclude-ext ike.orig/source/iked/ike.exch.phase2.cpp ike/source/iked/ike.exch.phase2.cpp
--- ike.orig/source/iked/ike.exch.phase2.cpp	2010-12-22 22:35:36.000000000 +0100
+++ ike/source/iked/ike.exch.phase2.cpp	2019-01-11 16:10:03.407126752 +0100
@@ -1008,14 +1008,14 @@
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, input.buff(), input.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1048,14 +1048,14 @@
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, input.buff(), input.size() );
+	HMAC_Final( ctx_prf, hash.buff(), NULL );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1093,14 +1093,14 @@
 
 	hash.size( ph1->hash_size );
 
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
-	HMAC_Update( &ctx_prf, input.buff(), input.size() );
-	HMAC_Final( &ctx_prf, hash.buff(), 0 );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_a.buff(), ( int ) ph1->skeyid_a.size(), ph1->evp_hash, NULL );
+	HMAC_Update( ctx_prf, input.buff(), input.size() );
+	HMAC_Final( ctx_prf, hash.buff(), 0 );
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	log.bin(
 		LLOG_DEBUG,
@@ -1549,13 +1549,16 @@
 
 	BDATA shared;
 
+    const BIGNUM * priv_key;
+    DH_get0_key(ph2->dh, NULL, &priv_key);
+
 	if( ph2->dhgr_id )
 	{
 		if( level >= LLOG_DECODE )
 		{
 			BDATA prv;
 			prv.size( ph2->dh_size );
-			BN_bn2bin( ph2->dh->priv_key, prv.buff() );
+			BN_bn2bin( priv_key, prv.buff() );
 
 			log.bin(
 				LLOG_DECODE,
@@ -1817,56 +1820,56 @@
 	// K3 = prf( SKEYID_d, K2 | [ g(qm)^xy | ] protocol | SPI | Ni_b | Nr_b )
 	//
 	
-	HMAC_CTX ctx_prf;
-	HMAC_CTX_init( &ctx_prf );
+	HMAC_CTX * ctx_prf;
+	ctx_prf = HMAC_CTX_new();
 
-	HMAC_Init_ex( &ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
+	HMAC_Init_ex( ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
 
 	if( ph2->dhgr_id )
-		HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
+		HMAC_Update( ctx_prf, shared.buff(), shared.size() );
 
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
-	HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
+	HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
 
 	if( ph2->initiator )
 	{
-		HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
-		HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
 	}
 	else
 	{
-		HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
-		HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+		HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
 	}
 
-	HMAC_Final( &ctx_prf, key_data, NULL );
+	HMAC_Final( ctx_prf, key_data, NULL );
 
 	for( long size = skeyid_size; size < key_size; size += skeyid_size )
 	{
-		HMAC_Init_ex( &ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
-		HMAC_Update( &ctx_prf, key_data + size - skeyid_size, skeyid_size );
+		HMAC_Init_ex( ctx_prf, ph1->skeyid_d.buff(), ( int ) ph1->skeyid_d.size(), ph1->evp_hash, NULL );
+		HMAC_Update( ctx_prf, key_data + size - skeyid_size, skeyid_size );
 
 		if( ph2->dhgr_id )
-			HMAC_Update( &ctx_prf, shared.buff(), shared.size() );
+			HMAC_Update( ctx_prf, shared.buff(), shared.size() );
 
-		HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
-		HMAC_Update( &ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
+		HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->proto, 1 );
+		HMAC_Update( ctx_prf, ( unsigned char * ) &proposal->spi, 4 );
 
 		if( ph2->initiator )
 		{
-			HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
-			HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
 		}
 		else
 		{
-			HMAC_Update( &ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
-			HMAC_Update( &ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_r.buff(), ph2->nonce_r.size() );
+			HMAC_Update( ctx_prf, ph2->nonce_l.buff(), ph2->nonce_l.size() );
 		}
 
-		HMAC_Final( &ctx_prf, key_data + size, 0 );
+		HMAC_Final( ctx_prf, key_data + size, 0 );
 	}
 
-	HMAC_CTX_cleanup( &ctx_prf );
+	HMAC_CTX_free( ctx_prf );
 
 	//
 	// separate encrypt and auth key data
diff -Nru -X exclude-ext ike.orig/source/iked/ike.idb.exch.cpp ike/source/iked/ike.idb.exch.cpp
--- ike.orig/source/iked/ike.idb.exch.cpp	2011-01-15 23:09:32.000000000 +0100
+++ ike/source/iked/ike.idb.exch.cpp	2019-01-11 16:16:18.664692959 +0100
@@ -134,12 +134,13 @@
 	unsigned char iv_data[ EVP_MAX_MD_SIZE ];
 	unsigned long iv_size = EVP_CIPHER_iv_length( ph1->evp_cipher );
 
-	EVP_MD_CTX ctx_hash;
-	EVP_DigestInit( &ctx_hash, ph1->evp_hash );
-	EVP_DigestUpdate( &ctx_hash, ph1->iv.buff(), ph1->iv.size() );
-	EVP_DigestUpdate( &ctx_hash, &msgid, 4 );
-	EVP_DigestFinal( &ctx_hash, iv_data, NULL );
-	EVP_MD_CTX_cleanup( &ctx_hash );
+	EVP_MD_CTX * ctx_hash;
+	ctx_hash = EVP_MD_CTX_new();
+	EVP_DigestInit( ctx_hash, ph1->evp_hash );
+	EVP_DigestUpdate( ctx_hash, ph1->iv.buff(), ph1->iv.size() );
+	EVP_DigestUpdate( ctx_hash, &msgid, 4 );
+	EVP_DigestFinal( ctx_hash, iv_data, NULL );
+	EVP_MD_CTX_free( ctx_hash );
 
 	iv.set( iv_data, iv_size );
 
diff -Nru -X exclude-ext ike.orig/source/iked/ike.idb.phase1.cpp ike/source/iked/ike.idb.phase1.cpp
--- ike.orig/source/iked/ike.idb.phase1.cpp	2011-02-01 08:21:32.000000000 +0100
+++ ike/source/iked/ike.idb.phase1.cpp	2019-01-11 16:11:19.894621059 +0100
@@ -676,7 +676,11 @@
 	}
 
 	xl.size( dh_size );
-	long result = BN_bn2bin( dh->pub_key, xl.buff() );
+
+    const BIGNUM * pub_key;
+    DH_get0_key(dh, &pub_key, NULL);
+
+	long result = BN_bn2bin( pub_key, xl.buff() );
 
 	//
 	// fixup public buffer alignment
diff -Nru -X exclude-ext ike.orig/source/iked/ike.idb.phase2.cpp ike/source/iked/ike.idb.phase2.cpp
--- ike.orig/source/iked/ike.idb.phase2.cpp	2012-11-20 00:28:52.000000000 +0100
+++ ike/source/iked/ike.idb.phase2.cpp	2019-01-11 16:11:41.614479031 +0100
@@ -438,7 +438,11 @@
 		}
 
 		xl.size( dh_size );
-		long result = BN_bn2bin( dh->pub_key, xl.buff() );
+
+		const BIGNUM * pub_key;
+		DH_get0_key(dh, &pub_key, NULL);
+
+		long result = BN_bn2bin( pub_key, xl.buff() );
 
 		//
 		// fixup public buffer alignment
diff -Nru -X exclude-ext ike.orig/source/iked/ike.keyfile.cpp ike/source/iked/ike.keyfile.cpp
--- ike.orig/source/iked/ike.keyfile.cpp	2012-12-15 23:14:32.000000000 +0100
+++ ike/source/iked/ike.keyfile.cpp	2019-01-11 17:49:41.781170771 +0100
@@ -1,4 +1,3 @@
-
 /*
  * Copyright (c) 2007
  *      Shrew Soft Inc.  All rights reserved.
@@ -634,7 +633,7 @@
 
     tsize = i2d_X509_NAME( name, &fbuff );
 	if( !tsize )
-		goto text_asn1_failed;
+		goto text_asn1_failed; 
 
 	//
 	// return success
@@ -664,14 +663,14 @@
 		long ll = LLOG_ERROR;
 		char name[ 512 ];
 
-		X509_NAME * x509_name = X509_get_subject_name( store_ctx->current_cert );
+		X509_NAME * x509_name = X509_get_subject_name( X509_STORE_CTX_get_current_cert(store_ctx) );
 
 		X509_NAME_oneline(
 			x509_name,
 			name,
 			512 );
 
-		switch( store_ctx->error )
+		switch( X509_STORE_CTX_get_error(store_ctx) )
 		{
 			case X509_V_ERR_UNABLE_TO_GET_CRL:
 				ok = 1;
@@ -683,9 +682,9 @@
 			ll,
 			"ii : %s(%d) at depth:%d\n"
 			"ii : subject :%s\n",
-			X509_verify_cert_error_string( store_ctx->error ),
-			store_ctx->error,
-			store_ctx->error_depth,
+			X509_verify_cert_error_string( X509_STORE_CTX_get_error(store_ctx) ),
+			X509_STORE_CTX_get_error(store_ctx),
+			X509_STORE_CTX_get_error_depth(store_ctx),
 			name );
 	}
 
@@ -857,7 +856,7 @@
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, EVP_PKEY_get0_RSA(evp_pkey) );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -883,7 +882,7 @@
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, EVP_PKEY_get0_RSA(evp_pkey) );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -939,7 +938,7 @@
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, EVP_PKEY_get0_RSA(evp_pkey) );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -976,7 +975,7 @@
 	if( evp_pkey == NULL )
 		return false;
 
-	bool converted = prvkey_rsa_2_bdata( prvkey, evp_pkey->pkey.rsa );
+	bool converted = prvkey_rsa_2_bdata( prvkey, EVP_PKEY_get0_RSA(evp_pkey) );
 	EVP_PKEY_free( evp_pkey );
 
 	return converted;
@@ -1010,7 +1009,7 @@
 	if( evp_pkey == NULL )
 		return false;
 
-	bool result = pubkey_rsa_2_bdata( pubkey, evp_pkey->pkey.rsa );
+ 	bool result = pubkey_rsa_2_bdata( pubkey, EVP_PKEY_get0_RSA(evp_pkey));
 
 	EVP_PKEY_free( evp_pkey );
 
diff -Nru -X exclude-ext ike.orig/source/iked/location.hh ike/source/iked/location.hh
--- ike.orig/source/iked/location.hh	1970-01-01 01:00:00.000000000 +0100
+++ ike/source/iked/location.hh	2019-01-11 17:50:08.997432924 +0100
@@ -0,0 +1,192 @@
+// A Bison parser, made by GNU Bison 3.0.4.
+
+// Locations for Bison parsers in C++
+
+// Copyright (C) 2002-2015 Free Software Foundation, Inc.
+
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+// As a special exception, you may create a larger work that contains
+// part or all of the Bison parser skeleton and distribute that work
+// under terms of your choice, so long as that work isn't itself a
+// parser generator using the skeleton or a modified version thereof
+// as a parser skeleton.  Alternatively, if you modify or redistribute
+// the parser skeleton itself, you may (at your option) remove this
+// special exception, which will cause the skeleton and the resulting
+// Bison output files to be licensed under the GNU General Public
+// License without this special exception.
+
+// This special exception was added by the Free Software Foundation in
+// version 2.2 of Bison.
+
+/**
+ ** \file location.hh
+ ** Define the yy::location class.
+ */
+
+#ifndef YY_YY_LOCATION_HH_INCLUDED
+# define YY_YY_LOCATION_HH_INCLUDED
+
+# include "position.hh"
+
+
+namespace yy {
+#line 46 "location.hh" // location.cc:296
+  /// Abstract a location.
+  class location
+  {
+  public:
+
+    /// Construct a location from \a b to \a e.
+    location (const position& b, const position& e)
+      : begin (b)
+      , end (e)
+    {
+    }
+
+    /// Construct a 0-width location in \a p.
+    explicit location (const position& p = position ())
+      : begin (p)
+      , end (p)
+    {
+    }
+
+    /// Construct a 0-width location in \a f, \a l, \a c.
+    explicit location (std::string* f,
+                       unsigned int l = 1u,
+                       unsigned int c = 1u)
+      : begin (f, l, c)
+      , end (f, l, c)
+    {
+    }
+
+
+    /// Initialization.
+    void initialize (std::string* f = YY_NULLPTR,
+                     unsigned int l = 1u,
+                     unsigned int c = 1u)
+    {
+      begin.initialize (f, l, c);
+      end = begin;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+  public:
+    /// Reset initial location to final location.
+    void step ()
+    {
+      begin = end;
+    }
+
+    /// Extend the current location to the COUNT next columns.
+    void columns (int count = 1)
+    {
+      end += count;
+    }
+
+    /// Extend the current location to the COUNT next lines.
+    void lines (int count = 1)
+    {
+      end.lines (count);
+    }
+    /** \} */
+
+
+  public:
+    /// Beginning of the located region.
+    position begin;
+    /// End of the located region.
+    position end;
+  };
+
+  /// Join two locations, in place.
+  inline location& operator+= (location& res, const location& end)
+  {
+    res.end = end.end;
+    return res;
+  }
+
+  /// Join two locations.
+  inline location operator+ (location res, const location& end)
+  {
+    return res += end;
+  }
+
+  /// Add \a width columns to the end position, in place.
+  inline location& operator+= (location& res, int width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /// Add \a width columns to the end position.
+  inline location operator+ (location res, int width)
+  {
+    return res += width;
+  }
+
+  /// Subtract \a width columns to the end position, in place.
+  inline location& operator-= (location& res, int width)
+  {
+    return res += -width;
+  }
+
+  /// Subtract \a width columns to the end position.
+  inline location operator- (location res, int width)
+  {
+    return res -= width;
+  }
+
+  /// Compare two location objects.
+  inline bool
+  operator== (const location& loc1, const location& loc2)
+  {
+    return loc1.begin == loc2.begin && loc1.end == loc2.end;
+  }
+
+  /// Compare two location objects.
+  inline bool
+  operator!= (const location& loc1, const location& loc2)
+  {
+    return !(loc1 == loc2);
+  }
+
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param loc a reference to the location to redirect
+   **
+   ** Avoid duplicate information.
+   */
+  template <typename YYChar>
+  inline std::basic_ostream<YYChar>&
+  operator<< (std::basic_ostream<YYChar>& ostr, const location& loc)
+  {
+    unsigned int end_col = 0 < loc.end.column ? loc.end.column - 1 : 0;
+    ostr << loc.begin;
+    if (loc.end.filename
+        && (!loc.begin.filename
+            || *loc.begin.filename != *loc.end.filename))
+      ostr << '-' << loc.end.filename << ':' << loc.end.line << '.' << end_col;
+    else if (loc.begin.line < loc.end.line)
+      ostr << '-' << loc.end.line << '.' << end_col;
+    else if (loc.begin.column < end_col)
+      ostr << '-' << end_col;
+    return ostr;
+  }
+
+
+} // yy
+#line 192 "location.hh" // location.cc:296
+#endif // !YY_YY_LOCATION_HH_INCLUDED
diff -Nru -X exclude-ext ike.orig/source/iked/position.hh ike/source/iked/position.hh
--- ike.orig/source/iked/position.hh	1970-01-01 01:00:00.000000000 +0100
+++ ike/source/iked/position.hh	2019-01-11 17:50:08.989432847 +0100
@@ -0,0 +1,180 @@
+// A Bison parser, made by GNU Bison 3.0.4.
+
+// Positions for Bison parsers in C++
+
+// Copyright (C) 2002-2015 Free Software Foundation, Inc.
+
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+// As a special exception, you may create a larger work that contains
+// part or all of the Bison parser skeleton and distribute that work
+// under terms of your choice, so long as that work isn't itself a
+// parser generator using the skeleton or a modified version thereof
+// as a parser skeleton.  Alternatively, if you modify or redistribute
+// the parser skeleton itself, you may (at your option) remove this
+// special exception, which will cause the skeleton and the resulting
+// Bison output files to be licensed under the GNU General Public
+// License without this special exception.
+
+// This special exception was added by the Free Software Foundation in
+// version 2.2 of Bison.
+
+/**
+ ** \file position.hh
+ ** Define the yy::position class.
+ */
+
+#ifndef YY_YY_POSITION_HH_INCLUDED
+# define YY_YY_POSITION_HH_INCLUDED
+
+# include <algorithm> // std::max
+# include <iostream>
+# include <string>
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+
+namespace yy {
+#line 56 "position.hh" // location.cc:296
+  /// Abstract a position.
+  class position
+  {
+  public:
+    /// Construct a position.
+    explicit position (std::string* f = YY_NULLPTR,
+                       unsigned int l = 1u,
+                       unsigned int c = 1u)
+      : filename (f)
+      , line (l)
+      , column (c)
+    {
+    }
+
+
+    /// Initialization.
+    void initialize (std::string* fn = YY_NULLPTR,
+                     unsigned int l = 1u,
+                     unsigned int c = 1u)
+    {
+      filename = fn;
+      line = l;
+      column = c;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+    /// (line related) Advance to the COUNT next lines.
+    void lines (int count = 1)
+    {
+      if (count)
+        {
+          column = 1u;
+          line = add_ (line, count, 1);
+        }
+    }
+
+    /// (column related) Advance to the COUNT next columns.
+    void columns (int count = 1)
+    {
+      column = add_ (column, count, 1);
+    }
+    /** \} */
+
+    /// File name to which this position refers.
+    std::string* filename;
+    /// Current line number.
+    unsigned int line;
+    /// Current column number.
+    unsigned int column;
+
+  private:
+    /// Compute max(min, lhs+rhs) (provided min <= lhs).
+    static unsigned int add_ (unsigned int lhs, int rhs, unsigned int min)
+    {
+      return (0 < rhs || -static_cast<unsigned int>(rhs) < lhs
+              ? rhs + lhs
+              : min);
+    }
+  };
+
+  /// Add \a width columns, in place.
+  inline position&
+  operator+= (position& res, int width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /// Add \a width columns.
+  inline position
+  operator+ (position res, int width)
+  {
+    return res += width;
+  }
+
+  /// Subtract \a width columns, in place.
+  inline position&
+  operator-= (position& res, int width)
+  {
+    return res += -width;
+  }
+
+  /// Subtract \a width columns.
+  inline position
+  operator- (position res, int width)
+  {
+    return res -= width;
+  }
+
+  /// Compare two position objects.
+  inline bool
+  operator== (const position& pos1, const position& pos2)
+  {
+    return (pos1.line == pos2.line
+            && pos1.column == pos2.column
+            && (pos1.filename == pos2.filename
+                || (pos1.filename && pos2.filename
+                    && *pos1.filename == *pos2.filename)));
+  }
+
+  /// Compare two position objects.
+  inline bool
+  operator!= (const position& pos1, const position& pos2)
+  {
+    return !(pos1 == pos2);
+  }
+
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param pos a reference to the position to redirect
+   */
+  template <typename YYChar>
+  inline std::basic_ostream<YYChar>&
+  operator<< (std::basic_ostream<YYChar>& ostr, const position& pos)
+  {
+    if (pos.filename)
+      ostr << *pos.filename << ':';
+    return ostr << pos.line << '.' << pos.column;
+  }
+
+
+} // yy
+#line 180 "position.hh" // location.cc:296
+#endif // !YY_YY_POSITION_HH_INCLUDED
diff -Nru -X exclude-ext ike.orig/source/iked/stack.hh ike/source/iked/stack.hh
--- ike.orig/source/iked/stack.hh	1970-01-01 01:00:00.000000000 +0100
+++ ike/source/iked/stack.hh	2019-01-11 17:50:08.997432924 +0100
@@ -0,0 +1,157 @@
+// A Bison parser, made by GNU Bison 3.0.4.
+
+// Stack handling for Bison parsers in C++
+
+// Copyright (C) 2002-2015 Free Software Foundation, Inc.
+
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+// As a special exception, you may create a larger work that contains
+// part or all of the Bison parser skeleton and distribute that work
+// under terms of your choice, so long as that work isn't itself a
+// parser generator using the skeleton or a modified version thereof
+// as a parser skeleton.  Alternatively, if you modify or redistribute
+// the parser skeleton itself, you may (at your option) remove this
+// special exception, which will cause the skeleton and the resulting
+// Bison output files to be licensed under the GNU General Public
+// License without this special exception.
+
+// This special exception was added by the Free Software Foundation in
+// version 2.2 of Bison.
+
+/**
+ ** \file stack.hh
+ ** Define the yy::stack class.
+ */
+
+#ifndef YY_YY_STACK_HH_INCLUDED
+# define YY_YY_STACK_HH_INCLUDED
+
+# include <vector>
+
+
+namespace yy {
+#line 46 "stack.hh" // stack.hh:132
+  template <class T, class S = std::vector<T> >
+  class stack
+  {
+  public:
+    // Hide our reversed order.
+    typedef typename S::reverse_iterator iterator;
+    typedef typename S::const_reverse_iterator const_iterator;
+
+    stack ()
+      : seq_ ()
+    {
+      seq_.reserve (200);
+    }
+
+    stack (unsigned int n)
+      : seq_ (n)
+    {}
+
+    inline
+    T&
+    operator[] (unsigned int i)
+    {
+      return seq_[seq_.size () - 1 - i];
+    }
+
+    inline
+    const T&
+    operator[] (unsigned int i) const
+    {
+      return seq_[seq_.size () - 1 - i];
+    }
+
+    /// Steal the contents of \a t.
+    ///
+    /// Close to move-semantics.
+    inline
+    void
+    push (T& t)
+    {
+      seq_.push_back (T());
+      operator[](0).move (t);
+    }
+
+    inline
+    void
+    pop (unsigned int n = 1)
+    {
+      for (; n; --n)
+        seq_.pop_back ();
+    }
+
+    void
+    clear ()
+    {
+      seq_.clear ();
+    }
+
+    inline
+    typename S::size_type
+    size () const
+    {
+      return seq_.size ();
+    }
+
+    inline
+    const_iterator
+    begin () const
+    {
+      return seq_.rbegin ();
+    }
+
+    inline
+    const_iterator
+    end () const
+    {
+      return seq_.rend ();
+    }
+
+  private:
+    stack (const stack&);
+    stack& operator= (const stack&);
+    /// The wrapped container.
+    S seq_;
+  };
+
+  /// Present a slice of the top of a stack.
+  template <class T, class S = stack<T> >
+  class slice
+  {
+  public:
+    slice (const S& stack, unsigned int range)
+      : stack_ (stack)
+      , range_ (range)
+    {}
+
+    inline
+    const T&
+    operator [] (unsigned int i) const
+    {
+      return stack_[range_ - i];
+    }
+
+  private:
+    const S& stack_;
+    unsigned int range_;
+  };
+
+
+} // yy
+#line 156 "stack.hh" // stack.hh:132
+
+#endif // !YY_YY_STACK_HH_INCLUDED
diff -Nru -X exclude-ext ike.orig/source/libike/manager.file.cpp ike/source/libike/manager.file.cpp
--- ike.orig/source/libike/manager.file.cpp	2011-02-06 17:40:00.000000000 +0100
+++ ike/source/libike/manager.file.cpp	2019-01-10 17:56:21.089289317 +0100
@@ -679,11 +679,13 @@
 			BDATA pwd;
 			data.get( pwd );
 
-			EVP_CIPHER_CTX ctx_cipher;
-			EVP_CIPHER_CTX_init( &ctx_cipher );
+			EVP_CIPHER_CTX * ctx_cipher;
+			ctx_cipher = EVP_CIPHER_CTX_new();
+
+			EVP_CIPHER_CTX_init( ctx_cipher );
 
 			EVP_CipherInit_ex(
-				&ctx_cipher,
+				ctx_cipher,
 				EVP_des_ede3_cbc(),
 				NULL,
 				key,
@@ -691,7 +693,7 @@
 				0 );
 
 			EVP_Cipher(
-				&ctx_cipher,
+				ctx_cipher,
 				pwd.buff(),
 				pwd.buff(),
 				( unsigned int ) pwd.size() );
